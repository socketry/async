<!DOCTYPE html>
<html>
	<head>
		
			<title>Event Loop</title>
		
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		
		<link rel="icon" type="image/png" href="../../_static/icon.png"/>
		<link rel="stylesheet" href="../../_static/site.css" type="text/css" media="screen"/>
		
		<script src="../../_components/jquery/jquery.min.js"></script>
		<script src="../../_components/jquery-syntax/jquery.syntax.min.js"></script>
		
		<script src="../../_static/links.js"></script>
		
		<script type="text/javascript">
		//<![CDATA[
			jQuery(function($) {
				$.syntax();
			});
		//]]>
		</script>
	</head>

	<body>
		<header> › <a class="link" href="../../index.html">Project</a> › <a class="link" href="../index.html">Guides</a></header>
		
		<main>
			
	<h1>Event Loop</h1>
	
	<p>This guide gives an overview of how the event loop is implemented.</p>
<section id="overview"><h2>Overview</h2>
<p><a href="../../source/Async/Reactor/index.html" title="Async::Reactor"><code class="language-ruby">class Async::Reactor</code></a> provides the event loop and sits at the root of any task tree. Work is scheduled by adding <a href="../../source/Async/Task/index.html" title="Async::Task"><code class="language-ruby">class Async::Task</code></a> instances to the reactor. When you invoke <a href="../../source/Async/Reactor/index.html#Async%3A%3AReactor%23async" title="Async::Reactor#async"><code class="language-ruby">Async::Reactor#async</code></a>, the parent task is determined by calling <a href="../../source/Async/Task/index.html#Async%3A%3ATask.current%3F" title="Async::Task.current?"><code class="language-ruby">Async::Task.current?</code></a> which uses fiber local storage. A slightly more efficient method is to use <a href="../../source/Async/Task/index.html#Async%3A%3ATask%23async" title="Async::Task#async"><code class="language-ruby">Async::Task#async</code></a>, which uses <code>self</code> as the parent task.</p>
<pre><code class="language-ruby">require 'async'

def sleepy(duration, task: Async::Task.current)
	task.async do |subtask|
		subtask.annotate &quot;I'm going to sleep #{duration}s...&quot;
		subtask.sleep duration
		puts &quot;I'm done sleeping!&quot;
	end
end

def nested_sleepy(task: Async::Task.current)
	task.async do |subtask|
		subtask.annotate &quot;Invoking sleepy 5 times...&quot;
		5.times do |index|
			sleepy(index, task: subtask)
		end
	end
end

Async do |task|
	task.annotate &quot;Invoking nested_sleepy...&quot;
	subtask = nested_sleepy
	
	# Print out all running tasks in a tree:
	task.print_hierarchy($stderr)
	
	# Kill the subtask
	subtask.stop
end
</code></pre>
</section><section id="thread-safety"><h3>Thread Safety</h3>
<p>Most methods of the reactor and related tasks are not thread-safe, so you'd typically have <a href="https://github.com/socketry/async-container">one reactor per thread or process</a>.</p>
</section><section id="embedding-reactors"><h3>Embedding Reactors</h3>
<p><code>Async::Reactor#run</code> will run until the reactor runs out of work to do. To run a single iteration of the reactor, use <code>Async::Reactor#run_once</code></p>
<pre><code class="language-ruby">require 'async'

Async.logger.debug!
reactor = Async::Reactor.new

# Run the reactor for 1 second:
reactor.async do |task|
	task.sleep 1
	puts &quot;Finished!&quot;
end

while reactor.run_once
	# Round and round we go!
end
</code></pre>
<p>You can use this approach to embed the reactor in another event loop.</p>
</section><section id="stopping-reactors"><h3>Stopping Reactors</h3>
<p><code>Async::Reactor#stop</code> will stop the current reactor and all children tasks.</p>
</section><section id="interrupting-reactors"><h3>Interrupting Reactors</h3>
<p><code>Async::Reactor#interrupt</code> can be called safely from a different thread (or signal handler) and will cause the reactor to invoke <code>#stop</code>.</p>
</section>
				
			<footer>Documentation generated by <a href="https://github.com/socketry/utopia-project">Utopia::Project</a>.</footer>
		</main>
	</body>
</html>